def indent(code, **kwargs):
    depth = kwargs.get('depth', 1)
    ws = ''.join(['  ' for d in range(depth)])
    if type(code) in (str, unicode):
        code = [code]
    return [ws + line for line in code]

def gen_system_include(path):
    return '#include <{}>'.format(path)

def gen_local_include(path):
    return '#include "{}"'.format(path)

def make_const(type_str):
    '''Make C++ type const'''
    return 'const ' + type_str

def make_ref(type_str, const=True):
    '''Make C++ type a reference

    If const is True, constify the type'''
    if const:
        type_str = make_const(type_str)
    return type_str + '&'

def gen_arg_list(elems):
    if len(elems) == 0:
        return ['()']
    elif len(elems) == 1:
        return ['(' + elems[0] + ')']
    else:
        code = ['(']
        for e in elems[:-1]:
            code += indent(e + ',', depth=2)
        code += indent(elems[-1] + ')', depth=2)
        return code

def gen_applied_arg_list(code, elems):
    code = code[:]
    args = gen_arg_list(elems)
    code[-1] += args[0]
    code += args[1:]
    return code

def gen_function(return_type, name, args,
                 static=False, body=None, class_name=None):
    qual = 'static ' if static and not body else ''
    if body and class_name:
        name = class_name + '::' + name
    if return_type != '':
        return_type += ' '
    code = [qual + return_type + name]
    code = gen_applied_arg_list(code, args)
    if body:
        code = gen_block(code, body)
    else:
        code[-1] += ';'
    return code

def gen_constructor_definition(class_name, args, body,
                               initializer_list=None,
                               scope=None):
    code = ['{1}{0}::{0}'.format(
            class_name,
            scope + '::' if scope else '')]
    code = gen_applied_arg_list(code, args)
    if initializer_list:
        code += indent([': ' + initializer_list])
    code = gen_block(code, body)
    return code

def gen_block(head, body, trailing_semicolon=False):
    code = head[:]
    code[-1] += ' {'
    code += indent(body)
    code += '}'
    if trailing_semicolon:
        code[-1] += ';'
    return code

def _gen_class_or_struct(keyword, name, body, inheritance):
    head = keyword + ' ' + name
    if inheritance:
        head += ' : ' + inheritance
    return gen_block([head], body, trailing_semicolon=True)

def gen_class(name, body, inheritance=None):
    return _gen_class_or_struct('class', name, body, inheritance)

def gen_struct(name, body, inheritance=None):
    return _gen_class_or_struct('struct', name, body, inheritance)

def append_trailing_commas(lines):
    """Return copy of lines with trailing commas appended."""
    result = []
    for (index, line) in enumerate(lines):
        # Append trailing comma if not last line
        if (index + 1) != len(lines):
            line = '{},'.format(line)
        result.append(line)
    return result

def gen_enum(name, members, cxx11=False):
    head = 'enum '
    if cxx11:
        head += 'class '
    head += name
    body = []
    for m in members:
        # Enum member
        line = m[0]
        if len(m) == 2:
            # Append member value if given
            line += ' = {}'.format(m[1])
        body.append(line)
    return gen_block([head], append_trailing_commas(body),
                     trailing_semicolon=True)

def gen_namespace(name, body):
    return ['namespace ' + name + ' {'] + body + ['}']

def gen_header(guard, body):
    return (['// THIS FILE IS AUTOGENERATED',
             '#ifndef ' + guard,
             '#define ' + guard,
             ''] +
            body +
            ['', '#endif  // ' + guard])

def camel_case_from_underscored(underscored):
    result = ''
    upcase = True
    for c in underscored:
        if c == '_':
            upcase = True
        elif upcase:
            upcase = False
            result += c.upper()
        else:
            result += c
    return result
            
            
def gen_if(condition_block_pairs, else_block=None):
    """Generate a C++ if/else if/else chain

    condition_block_pairs is a sequence of pairs, where the first part
    of the pair is the conditional and the second part is the block
    associated with that condition.

    else_block is an optional code block that will cause an else to be
    added at the end of the chain.

    An exception is thrown if condition_block_pairs is an empty
    sequence.

    """
    code = []
    for pair in condition_block_pairs:
        condition = pair[0]
        block = pair[1]
        prefix = '' if len(code) == 0 else 'else '
        control = ['{}if ({})'.format(prefix, condition)]
        code += gen_block(control, block)
    if not code:
        raise Exception('condition_block_pairs is empty')
    if else_block:
        code += gen_block(['else'], else_block)
    return code
